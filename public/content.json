[{"title":"hexo&github创建个人博客","date":"2018-11-07T06:27:37.000Z","path":"2018/11/07/hexo&github创建个人博客/","text":"利用 hexo 和 github 搭载个人博客 准备工作 安装了 node.js, npm, 并会使用 了解git 配置 SSH key 用 git 或者 cmder 等命令行工具执行： cd ~/. ssh # 检查本机已存在的ssh密钥 如果显示 No such file or directory 说明还未设置过 SSH key 执行： ssh-keygen -t rsa -C \"邮件地址\" 然后持续回车, 最后会生成一个文件在 .ssh\\id_rsa.pub 中, 用记事本打开该文件, 复制里面的内容。 打开你的 github 主页, 进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key 将刚复制的内容粘贴到 key 那里, title 取个自己喜欢的, 然后保存。 测试是否成功 ssh -T git@github.com # 注意邮箱地址不用改 如果提示 Are you sure you want to continue connecting (yes/no)? , 输入yes, 然后就会提示 ...You’ve successfully authenticated, but GitHub does not provide shell access., 就是成功了。 配置 git 用户名和邮箱 git config --global user.name \"username\" git config --global user.email \"email\" github 创建 github 账号 创建 github 个人项目 username.github.io 创建分支 hexo 设置 hexo 为默认分支 使用 git clone git@github.com:username/username.github.io.git 拷贝仓库 Hexohexo官网 hexo github 安装# npm 或者 cnpm 安装 npm install -g hexo-cli 初始化在刚刚 git clone 的这个文件夹中, 执行： # 此时当前分支应显示为 hexo npm install hexo hexo init npm install npm install hexo-deployer-git 执行以上命令之后, hexo 就会在文件夹中生成博客相关文件 将 hexo 部署到 username.github.io在 _config.yml 中修改： deploy: type: git repository: git@github.com:shmilybaozi/shmilybaozi.github.io.git branch: master hexo g # hexo generate 生成静态文件 hexo g -d # 文件生成后立即部署网站 开始使用一些 hexo 命令 hexo new [layout] &lt;title> # 新建一篇文章, 如果标题包含空格的话, 请使用引号括起来。layout 为 draft 即为草稿 hexo publish [layout] &lt;filename> # 发表草稿, 如果标题包含空格的话, 请使用引号括起来。 hexo g # hexo generate 生成静态文件 hexo g -d # 文件生成后立即部署网站 hexo s # hexo server 启动服务器 hexo d # hexo deploy 部署网站 hexo clean # 清除缓存 hexo s --debug # 调试模式, 更改了配置或文章后随时刷新页面来查看效果 部署文章的步骤hexo clean # 清除缓存 hexo g -d # 文件生成后立即部署网站 将 hexo 中的代码提交到 git 上git add . git commit -m \"...\" git push origin hexo 这样一来, 在 github 上的 username.github.io 仓库就有两个分支, 一个 hexo 分支用来存放网站的原始文件, 一个 master 分支用来存放生成的静态网页。 访问 username.github.io 就能看到个人博客的样子。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://shmilybaozi.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://shmilybaozi.github.io/tags/Github/"}]},{"title":"hexo文章模板设置","date":"2018-11-05T14:57:26.000Z","path":"2018/11/05/hexo文章模板设置/","text":"hexo文章模板设置 hexo文章模板设置hexo 项目文件夹中的 scaffold 文件夹中的 post.md 和 draft.md 对应就是 hexo new [layout] &lt;title&gt; 中的 layout , 默认为 post, 草稿为 draft, 如果标题包含空格的话，请使用引号括起来。 --- title: {{ title }} tags: categories: description: date: {{ date }} --- 点击阅读前文前, 首页能看到的文章的简短描述 &lt;!-- more --> &lt;!-- markdownlint-disable MD041 MD002--> # 防止 markdownlint 报错 hexo 草稿Hexo 的一种特殊布局：draft, 这种布局在建立时会被保存到 source/_drafts 文件夹, 您可通过 publish 命令将草稿移动到 source/_posts 文件夹。 该命令的使用方式与 new 十分类似, 您也可在命令中指定 layout 来指定布局。 hexo publish [layout] &lt;title> # 发表草稿 草稿默认不会显示在页面中, 您可在执行时加上 --draft 参数, 或是把 render_drafts 参数设为 true 来预览草稿。 hexo 分类和标签分类具有顺序性和层次性。Hexo 不支持指定多个同级分类。 标签没有顺序和层次。 categories: - Diary - Life tags: - PS3 - Games 以上会使分类 Life 成为 Diary 的子分类, 而不是并列分类。 因此，有必要为您的文章选择尽可能准确的一个分类","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://shmilybaozi.github.io/tags/Hexo/"}]},{"title":"Vue中使用 Webpack总结","date":"2018-08-07T07:42:09.000Z","path":"2018/08/07/Vue中使用Webpack总结/","text":"Webpack 打包工具(模块打包器) Webpack结构Vue中 关于Webpack的配置文件有四个: (vue-cli版本@2.9.6) build文件夹 webpack.base.conf.js 主要配置文件 webpack.dev.conf.js 开发环境配置文件 webpack.prod.conf.js 生产环境配置文件 webpack.test.conf.js 需要单元测试时的配置文件(不选择单元测试则没有该文件) webpack.base.conf.js'use strict' const path = require('path') const utils = require('./utils') const config = require('../config') const vueLoaderConfig = require('./vue-loader.conf') function resolve (dir) { return path.join(__dirname, '..', dir) } const createLintingRule = () => ({ test: /\\.(js|vue)$/, loader: 'eslint-loader', enforce: 'pre', include: [resolve('src'), resolve('test')], options: { formatter: require('eslint-friendly-formatter'), emitWarning: !config.dev.showEslintErrorsInOverlay } }) module.exports = { // 基础目录，绝对路径，用于从配置中解析入口起点(entry point)和 loader context: path.resolve(__dirname, '../'), // 入口配置: 可以配置多入口 entry: { app: './src/main.js' }, // 出口配置 output: { // 出口路径: path必须是绝对路径 path: config.build.assetsRoot, // 出口文件名 filename: '[name].js', // [name]即入口名称 // 对于按需加载(on-demand-load)或加载外部资源(external resources)（如图片、文件等）来说，output.publicPath 是很重要的选项。 // 该选项的值是以 runtime(运行时) 或 loader(载入时) 所创建的每个 URL 为前缀。因此，在多数情况下，此选项的值都会以/结束。 // 可能以下情况中的一种: publicPath: 'https://cdn.example.com/assets/', // CDN（总是 HTTPS 协议） publicPath: '//cdn.example.com/assets/', // CDN（协议相同） publicPath: '/assets/', // 相对于服务(server-relative) publicPath: 'assets/', // 相对于 HTML 页面 publicPath: '../assets/', // 相对于 HTML 页面 publicPath: '', // 相对于 HTML 页面（目录相同） // Vue中: 判断环境变量的值,去对应的环境变量中寻找设置 config 文件夹中的 index.js publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath // 默认为\"/\"，一般会修改为\"./\" : config.dev.assetsPublicPath // 默认为\"/\" }, // 配置模块如何解析 resolve: { // 自动解析确定的扩展: 能够使用户在引入模块时不带扩展 extensions: ['.js', '.vue', '.json'], // 创建 import 或 require 的别名，来确保模块引入变得更简单。 alias: { 'vue$': 'vue/dist/vue.esm.js', // 在给定对象的键后的末尾添加 $,以表示精准匹配: 必须以 XXX 结尾 '@': resolve('src'), // js文件!!!中 @ 即表示为 src 文件夹, html 和 css 路径中不是 } }, // 决定如何处理项目中的不同类型的模块 module: { // 创建模块时，匹配请求的规则数组。这些规则能够修改模块的创建方式。这些规则能够对模块(module)应用 loader，或者修改解析器(parser) rules: [ ...(config.dev.useEslint ? [createLintingRule()] : []), { test: /\\.vue$/, loader: 'vue-loader', options: vueLoaderConfig }, { test: /\\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')] }, { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') } }, { test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: utils.assetsPath('media/[name].[hash:7].[ext]') } }, { test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') } } ] }, node: { // prevent webpack from injecting useless setImmediate polyfill because Vue // source contains it (although only uses it if it's native). setImmediate: false, // prevent webpack from injecting mocks to Node native modules // that does not make sense for the client dgram: 'empty', fs: 'empty', net: 'empty', tls: 'empty', child_process: 'empty' } } 在最新的 vue-cli 3.0 中, webpack 中的设置都隐藏到了 vue 内部, 通过设置 vue.config.js 来覆盖相关 webpack 设置","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shmilybaozi.github.io/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://shmilybaozi.github.io/tags/Webpack/"}]},{"title":"path.join 和 path.resolve区别","date":"2018-08-06T02:11:44.000Z","path":"2018/08/06/path.join和path.resolve区别/","text":"path.join &amp; path.resolve path.join([path1][, path2][, …])path.join(): 连接任意多个路径字符串。 注：如果连接后的路径字符串是一个长度为零的字符串, 则返回 &#39;.&#39;, 表示当前工作目录。 path.join('foo', 'bar', 'baz') // 返回 '/foo/bar/baz' // 不合法的字符串将抛出异常 path.join('foo', {}, 'bar') // 抛出的异常 TypeError: Arguments to path.join must be strings' path.resolve([from…], to)path.resolve(): 将多个路径解析为一个规范化的绝对路径。 其处理方式类似于对这些路径逐一进行 cd 操作, 与 cd 操作不同的是, 这引起路径可以是文件, 并且可不必实际存在（resolve()方法不会利用底层的文件系统判断路径是否存在, 而只是进行路径字符串操作。） path.resolve(&#39;foo/bar&#39;, &#39;/tmp/file/&#39;, &#39;..&#39;, &#39;a/../subFile&#39;) 相当于: cd foo/bar cd /tmp/file/ cd .. cd a/../subFile pwd # Linux pwd命令用于显示工作目录。执行 pwd 指令可立刻得知您目前所在的工作目录的绝对路径名称。 path.resolve('/foo/bar', './baz') // 输出结果为 '/foo/bar/baz' path.resolve('/foo/bar', '/tmp/file/') // 输出结果为 '/tmp/file' path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif') // 当前的工作路径是 /home/myself/node, 则输出结果为 '/home/myself/node/wwwroot/static_files/gif/image.gif' 两者的区别 join 是把各个 path 片段连接在一起， resolve 把&#39;/&#39; 当成根目录 path.join('/a', '/b') // '/a/b' path.resolve('/a', '/b') // '/b' join 直接拼接字段，resolve 解析路径并返回绝对路径 path.join('a', 'b1', '..', 'b2') // 'a/b2' path.resolve('a', 'b1', '..', 'b2') // '/home/myself/node/a/b2'","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://shmilybaozi.github.io/tags/JavaScript/"}]},{"title":"Git更新与推送流程","date":"2018-07-29T07:48:01.000Z","path":"2018/07/29/Git更新与推送流程/","text":"Git更新与推送流程 Git更新与推送流程 设置主仓库地址 git remote add upstream https://repo-address 获取主仓库最新提交 git pull upstream 将主仓库的 master 分支合并到本地的 master 分支 git merge upstream/master master 解决冲突并提交合并 git commit -a -m 'merge upstream master' 推送至远程仓库 git push 提交Pull Request 自定义Git让Git显示颜色git config --global color.ui true 配置别名 git st表示git status git co表示git checkout git ci表示git commit git br表示git branch git config --global alias.st status git config --global alias.co checkout git config --global alias.ci commit git config --global alias.br branch 命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名： git config --global alias.unstage 'reset HEAD' 配置一个git last，让其显示最后一次提交信息： git config --global alias.last 'log -1' 还有人丧心病狂地把lg配置成了： git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an>%Creset' --abbrev-commit\" 配置文件配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。配置文件放哪了?每个仓库的Git配置文件都放在.git/config文件中而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。 [alias] st = status co = checkout ci = commit br = branch unstage = reset HEAD last = log -1 lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an>%Creset' --abbrev-commit up = upstream og = origin ms = master mg = merge plp = pull upstream mgums = merge upstream/master master rap = remote add upstream rag = remote add origin psg = push -u origin","tags":[{"name":"Git","slug":"Git","permalink":"https://shmilybaozi.github.io/tags/Git/"}]},{"title":"src目录结构分析","date":"2018-07-08T15:15:22.000Z","path":"2018/07/08/src目录结构分析/","text":"src目录结构及命名原则分析 src目录结构分析. ├── adapter -----> 适配器,处理拿到的数据,整理成对象或者别的能直接使用的数据 | ├── report.js -----> (驼峰命名：与api命名一致) | └── selectPhoneNumber.js -----> (驼峰命名: 与api命名一致) | ├── api -----> 通过后台接口拿到数据 | ├── report.js -----> (驼峰命名) | └── selectPhoneNumber.js -----> (驼峰命名) | ├── assets -----> 存放图片 | ├── components -----> 组件,通过在 views 中的 vue 文件的调用并传入数据,然后渲染在页面中,复用性强 | ├── AreaCard.vue -----> (Pascal命名) | ├── Chart.vue | └── Entry.vue | ├── router -----> 路由 | └── index.js | ├── store -----> vuex | ├── modules -----> vuex模块 | | ├── clothesSize.js -----> (驼峰命名) | | ├── login.js | | └── user.js | └── index.js | ├── util -----> 自己封装的 js | ├── fetch.js | └── index.js | └── views -----> 页面展示 ├── Report.vue -----> (Pascal命名: 与api命名一致) ├── Dormitory | ├── DormitoryStudent.vue -----> (Pascal命名) | ├── Edit.vue | └── index.vue └── Home.vue 注：api —–&gt; adapter —–&gt; views —–&gt; 同一个页面：这三个文件夹的命名对应一致 或者 api、adapter 与 views 中的文件夹命名一致","tags":[{"name":"Vue","slug":"Vue","permalink":"https://shmilybaozi.github.io/tags/Vue/"}]},{"title":"前端开发环境配置","date":"2018-07-01T08:19:21.000Z","path":"2018/07/01/前端开发环境配置/","text":"前端开发环境配置、淘宝镜像及跨域处理 开发环境准备工作安装软件 NodeJS 10版本以上 [win]Cmder VS Code [win]Git NPM和Yarn添加淘宝镜像NPM设置淘宝镜像 查询当前配置的镜像 npm get registry // https://registry.npmjs.org/ 设置成淘宝镜像 npm config set registry http://registry.npm.taobao.org/ 换成原来的 npm config set registry https://registry.npmjs.org/ Yarn 设置淘宝镜像 查询当前配置的镜像 yarn config get registry // https://registry.yarnpkg.com 设置成淘宝镜像 yarn config set registry http://registry.npm.taobao.org/ 安装vue脚手架和 eslint[sudo] yarn global add vue-cli [sudo] yarn global add eslint [sudo] yarn global add eslint mocha 安装VS code插件 Auto Close Tag Auto Rename Tag ESLint HTML Snippets JavaScript Standard Format language-stylus Path Intellisense Vetur Vue 2 Snippets Settings Sync 同步插件 chrome浏览器跨域版本号49之前的跨域设置 下载并安装好chrome浏览器后在桌面找到浏览器快捷图标并点击鼠标右键的属性一栏。 在属性页面中的目标输入框...exe&quot;后加上 --disable-web-security 点击应用和确定后关闭属性页面，并打开chrome浏览器。 如果浏览器出现提示“你使用的是不受支持的命令标记–disable-web-security”，那么说明配置成功。 版本号49之后的chrome跨域设置 在电脑上新建一个目录，例如：C:\\MyChromeDevUserData 在属性页面中的目标输入框...exe&quot;后加上 --disable-web-security --user-data-dir=C:\\MyChromeDevUserData,–user-data-dir的值就是刚才新建的目录。 点击应用和确定后关闭属性页面，并打开chrome浏览器。 再次打开chrome，发现有“–disable-web-security”相关的提示，说明chrome又能正常跨域工作了。 其他 Chai 断言语法 如何使用 Mocha, Chai 和 SuperTest 写测试代码 如果报错 error An unexpected error occurred: &quot;https://registry.npm.taobao.org/axios: unable to verify the first certificate&quot;.就设置 npm/yarn config set strict-ssl false","tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://shmilybaozi.github.io/tags/VSCode/"},{"name":"淘宝镜像","slug":"淘宝镜像","permalink":"https://shmilybaozi.github.io/tags/淘宝镜像/"},{"name":"跨域","slug":"跨域","permalink":"https://shmilybaozi.github.io/tags/跨域/"}]},{"title":"Yarn 和 NPM 命令","date":"2018-07-01T07:34:24.000Z","path":"2018/07/01/Yarn和NPM命令/","text":"Yarn 和 NPM 命令 Yarn和 NPM命令 NPM是随同 NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题 Yarn 是一个新的包管理器，用于替代现有的 npm 客户端或者其他兼容 npm 仓库的包管理工具。Yarn 保留了现有工作流的特性，优点是更快、更安全、更可靠。 命令 NPM Yarn 安装 新版的NodeJS 已经集成了NPM npm install -g yarn 升级 npm install npm -g 见Yarn升级 安装所有的依赖包 npm install yarn 安装某个依赖 npm install [package] --save/-S yarn add [package] 安装某个开发时依赖项目 npm install [package] --save-dev/-D yarn add [package] --dev/-D 安装某个全局依赖项目 npm install [package] -g yarn global add [package] 更新某个依赖 npm update [package] yarn upgrade [package] 更新某个依赖到某个版本 npm update [package@version] yarn upgrade [package@version] 更新某个依赖到最新版本 npm update [package@latest] yarn upgrade [package] --latest 删除某个依赖 npm uninstall [package] yarn remove [package] 运行脚本 npm run yarn run 可以通过输入npm -v来测试是否成功安装 npm -v 6.2.0 NPM 常用命令 NPM提供了很多命令，使用npm help可查看所有命令。 使用npm help &lt;command&gt;可查看某条命令的详细帮助，例如npm help install 使用淘宝 NPM 镜像NPM和 Yarn添加淘宝镜像 Yarn升级通过msi安装升级 Yarn下载最新的yarn更新包 通过 msi 安装的 yarn 并不会覆盖通过 npm 安装的 yarn，两者同时存在。卸载的话，也是分开卸载的。 NPM加版本号安装虽然，我们不能通过npm install yarn -g的方法，获得最新的yarn。但是，我们已经知道了yarn的最新版的版本号，所以，我们可以直接指定版本号进行安装。 npm install yarn@1.9.2 -g 这样的话，就可以不使用msi，而还是采用更高大上的命令行模式安装最新版的yarn了。我们可以用npm view yarn version，查看NPM上的最新版本。 NPM 加 latest 安装npm install yarn@latest -g","tags":[{"name":"NPM","slug":"NPM","permalink":"https://shmilybaozi.github.io/tags/NPM/"},{"name":"Yarn","slug":"Yarn","permalink":"https://shmilybaozi.github.io/tags/Yarn/"}]}]